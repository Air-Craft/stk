/*! \page fundamentals STK Fundamentals

The Synthesis ToolKit is implemented in the C++ programming language.  STK does not attempt to provide a new programming environment or paradigm but rather provides a set of objects which can be used within a normal C++ programming framework.  Therefore, it is expected that users of STK will have some familiarity with C/C++ programming concepts.  That said, the STK classes do have some particular idiosyncrasies that we will mention here.

\section Signal Computations:

Audio and control signals throughout STK use a floating-point data type, <tt>StkFloat</tt>, the exact precision of which can be controlled via a typedef statement in Stk.h.  By default, an StkFloat is a double-precision floating-point value.  Thus, the ToolKit can use any normalization scheme desired. The base instruments and algorithms are implemented with a general audio sample dynamic maximum of +/-1.0.

In general, the computation and/or passing of values is performed on a "single-sample" basis.  For example, the Noise class outputs random floating-point numbers in the range +/-1.0.  The computation of such values occurs in the Noise::tick() function.  The following program will generate 20 random floating-point (<tt>StkFloat</tt>) values in the range -1.0 to +1.0:

\code
#include "Noise.h"

int main()
{
  StkFloat output;
  Noise noise;

  for ( unsigned int i=0; i<20; i++ ) {
    output = noise.tick();
    std::cout << "i = " << i << " : output = " << output << std::endl;
  }

  return 0;
}
\endcode

Nearly all STK classes implement <TT>tick()</TT> functions that take and/or return sample values. Within the <TT>tick()</TT> function, the fundamental sample calculations are performed for a given class.  Most STK classes consume/generate a single sample per operation and their <TT>tick()</TT> method takes/returns each sample "by value".  In addition, every class implementing a <TT>tick()</TT> function also provides one or more overloaded <TT>tick()</TT> functions which can be used for vectorized computations, as shown in the next example.

\code
#include "Noise.h"

int main()
{
  StkFrames output(20, 1);   // initialize StkFrames to 20 frames and 1 channel (default: interleaved)
  Noise noise;

  noise.tick( output );
  for ( unsigned int i=0; i<output.size(); i++ ) {
    std::cout << "i = " << i << " : output = " << output[i] << std::endl;
  }

  return 0;
}
\endcode

In this way, it might be possible to achieve improved processing efficiency using vectorized computations.  The StkFrames class is a relatively new addition to the ToolKit to provide a general "mechanism" for handling and passing vectorized, multi-channel audio data.  The StkFrames "type" provides functions to set and/or determine the number of audio channels and sample frames it holds, as well as the format (interleaved or non-interleaved) of its data.  Further, the StkFrames class provides data interpolation and subscripting functionality by frame/channel values.

\section STK Inheritance:

Nearly all STK classes inherit from the Stk abstract base class, which provides common functionality related to error reporting, sample rate control, and byte swapping.  Several other base classes exist which roughly group many of the classes according to function as follows:

- Generator: source signal unit generator classes [Envelope, ADSR, Asymp, Noise, SubNoise, Modulate, SingWave, SineWave Blit, BlitSaw, BlitSquare, Granulate]
- Filter: digital filtering classes [OneZero, OnePole, PoleZero, TwoZero, TwoPole, BiQuad, FormSwep, Delay, DelayL, DelayA]
- Function: input to output function mappings [BowTable, JetTable, ReedTable]
- Instrmnt: sound synthesis algorithms, including physical, FM, modal, and particle models
- Effect: sound processing effect classes [Echo, Chorus, PitShift, PRCRev, JCRev, NRev]
- WvOut: audio data output classes [FileWvOut, RtWvOut, InetWvOut]
- WvIn: audio data input classes [FileWvIn, WaveLoop, RtWvIn, InetWvIn]


[<A HREF="tutorial.html">Main tutorial page</A>] &nbsp; [<A HREF="hello.html">Next tutorial</A>] 
*/
